/******  These lines are copied from ~/research/Neuron/shared/hoc/syn_params.hoc  *******************/

//define these now, redefine when used
objref stimEsyndend[100], connEsyndend[100], Esyndend[100]
objref stimIsyndend[100], connIsyndend[100], Isyndend[100]
objref stimEsynsoma[1], connEsynsoma[1], Esynsoma[1]
objref stimIsynsoma[1], connIsynsoma[1], Isynsoma[1]
objref stimEsynprox[1], connEsynprox[1], Esynprox[1]
objref stimIsynprox[1], connIsynprox[1], Isynprox[1]
objref stimEsyndist[1], connEsyndist[1], Esyndist[1]
objref stimIsyndist[1], connIsyndist[1], Isyndist[1]

EXTHZ = 4 //Hz //10 //
INTHZ = 1 //Hz //65 //
NOISE = 0

ISI_EXC = 1000/INTHZ
ISI_INH = 1000/INTHZ
START_EXC = 50
START_INH = 50

//densities of AMPA, GABA are per 100um^2, 
GABAaDENDDEN=1//10 //density of GABAa at dendrites 
AMPADENDDEN=1//60 //density of AMPA at dendrites 
TOTAL_GABAa_g=491.4 //nS
TOTAL_AMPA_g =5898 //nS 



NSEG= 27
NSEG_SPINE=3 

OFFSET=50 //start 
ONSET=50  //end of applying events
NOISE=0
CURRINJ=0.03 // current injected
DT = 0.025
TSTOP = 1000 //
PLOTSMS=4


// These parameter values are modified from Traub, Contreras, et al. 2005:  
// Single-column thalamocortical network model exhibiting gamma oscillations,
// sleep spindles and epileptogenic bursts.  J Neurophysiol 93(4):  2194-2232,
// (2005).  PMID:  15525801.  See Appendix B, starting on page 2224.
//
// These are from superficial pyramid parameters reported in that reference.
// Note some alternative conductances reported for different connection types,
// e.g. pyramid->pyramid AMPA connections vs. stellate->pyramid connections.
// See Traub et al. to see which connections use which conductance values.


//
// values for MSN model in Wolf et al. 
//
  AMPA_tau1 = 4  //(ms), time constant for AMPA
  AMPA_tau2 = 12     //(ms), 

  AMPA_Esyn = 0  //reversal potential 
  AMPA_g=0.0002 // change in conductance



  GABAa_g=0.0021  // 1.0nS // change in conductance; other connections used 0.05 nS, 0.1 nS
  GABAa_Esyn = -60 //reversal potential for superficial pyramids; other neuron types in the model used -75 mV
  GABAa_tau1 = 0.5 //  
  GABAa_tau2 = 7.5 //  



START_EXC = 200

/*********************************************

    input	$o1	SectionList where synapses are needed
		$o2	vector of synapse locations
		$3	starting time of excitation
		$4	timing between subsequent PSPs
*********************************************/
func AddSynapses() { local cnt, nSyn, DELAY, ST_EXC, stopTime

    nSyn = $o2.size()
    ST_EXC = $3
    DELAY  = $4

    objref stimEsyndend[nSyn], connEsyndend[nSyn], Esyndend[nSyn]

    cnt = 0
    forsec $o1 {
	Esyndend[cnt] = new Exp2Syn($o2.x[cnt])
	Esyndend[cnt].tau1=AMPA_tau1  //--- ms decay time constatn
	Esyndend[cnt].tau2=AMPA_tau2  //--- ms decay time constatn
	Esyndend[cnt].e=AMPA_Esyn //-- mV reversal potential

	stimEsyndend[cnt]= new NetStim($o2.x[cnt])
	stimEsyndend[cnt].interval=  100
	stimEsyndend[cnt].start= $3 + cnt*DELAY
	stimEsyndend[cnt].noise=0
	stimEsyndend[cnt].number=1

        connEsyndend[cnt] = new NetCon(stimEsyndend[cnt],Esyndend[cnt],-55,0,AMPA_g)

        cnt += 1
    }
    stopTime = START_EXC+(nSyn+2)*DELAY
    printf("Added %d synapses, final time %d\n",nSyn,START_EXC + nSyn*DELAY)

    return stopTime
}

objref sref

/*********************************************

    input	$1	total number of excitatory apical synapses
    		$2	total number of excitatory basal synapses
		$3	starting time of excitation
		$4	timing between subsequent PSPs
		$o5	SectionList to which sections are added
		$o6	vector of locations

*********************************************/
func AddExcSynapses_byNumber() { local cnt, nSyn, DELAY, ST_EXC, stopTime, SAspacing, totSA, SAcnt, numSec, cntSec, xloc

    nASyn   = $1
    nBSyn   = $2
    nCSyn   = $3
    nSyn = nASyn + nBSyn + nCSyn

    ST_EXC = $4
    DELAY  = $5

    objref stimEsyndend[nSyn], connEsyndend[nSyn], Esyndend[nSyn]
    soma { distance(0) }
    $o6 = new SectionList()
    $o7 = new Vector()

    // proximal synapses first
    if( nASyn > 0 ) {

        totSA = 0
        forsec proximal {
	        totSA =totSA + L*3.1415926*diam
        }

        SAspacing = totSA / nASyn
        printf("Spacing for proximal EXC synapses:  every %g = %g / %d microns ^ 2\n",SAspacing,totSA,nASyn)
        SAcnt = 0
        cnt = 0

        /***  no excitatory synapses added to soma ***/
        numSec = 0
        forsec proximal { numSec += 1 }

        cntSec = 0
        forsec proximal {
            cntSec += 1
	    	    for(x) {
	        SAcnt += area(x)
	        while( SAcnt >= SAspacing ) {
		    // add synapse here

   		    sref = new SectionRef()
		    $o6.append()
		    $o7.append(x)

		    //printf("SynLoc[%d] %s(%g) Dist %g\tCutoff %g > %g, total %g out of %g\n",cnt,secname(),x,distance(x), SAcnt,SAspacing,SAcnt+cnt*SAspacing,totSA)
		    Esyndend[cnt] = new Exp2Syn(x)
		    Esyndend[cnt].tau1=AMPA_tau1  //--- ms decay time constatn
		    Esyndend[cnt].tau2=AMPA_tau2  //--- ms decay time constatn
		    Esyndend[cnt].e=AMPA_Esyn //-- mV reversal potential


		    stimEsyndend[cnt]= new NetStim(x)
		    stimEsyndend[cnt].interval=  100
		    stimEsyndend[cnt].start= $3 + cnt*DELAY
		    stimEsyndend[cnt].noise=0
		    stimEsyndend[cnt].number=1

		    
	            connEsyndend[cnt] = new NetCon(stimEsyndend[cnt],Esyndend[cnt],-55,0,AMPA_g)
	            connEsyndend[cnt].record(tvec, idvec, cnt)
	            cnt += 1

		    SAcnt -= SAspacing
	        }
    	    }
    	 
            // if it's the end of the SectionList and we still have a synapse to add, put it here.
	    if( cnt < nASyn && cntSec == numSec ) {
	        //printf("---Added %d synapses, need a total of %d\n",cnt,nSyn)
	        while( cnt < nASyn ) {
	            xloc = 1

 		    // add synapse here

		    sref = new SectionRef()
		    $o6.append()
		    $o7.append(xloc)

		    //printf("\t\tSynLoc[%d] %s(%g) Dist %g\n",cnt,secname(),xloc,distance(xloc))
		    Esyndend[cnt] = new Exp2Syn(xloc)
		    Esyndend[cnt].tau1=AMPA_tau1  //--- ms decay time constatn
		    Esyndend[cnt].tau2=AMPA_tau2  //--- ms decay time constatn
		    Esyndend[cnt].e=AMPA_Esyn //-- mV reversal potential


		    stimEsyndend[cnt]= new NetStim(xloc)
		    stimEsyndend[cnt].interval=  100
		    stimEsyndend[cnt].start= $4 + cnt*DELAY
		    stimEsyndend[cnt].noise=0
		    stimEsyndend[cnt].number=1
		    
	            connEsyndend[cnt] = new NetCon(stimEsyndend[cnt],Esyndend[cnt],-55,0,AMPA_g)
	            connEsyndend[cnt].record(tvec, idvec, cnt)
	            cnt += 1
	        }
            }
        }
        printf("Finished with proximal dendrites, added %d synapses, %g SA till next synapse\n",cnt,SAcnt)
        }else { printf("No apical synapses added.\n") }

    // now basal synapses
    if( nBSyn > 0 ) {

        totSA = 0
        forsec middend {
	        totSA += L*3.1415926*diam
        }

        SAspacing = totSA / nBSyn
        printf("Spacing for middend EXC synapses:  every %g = %g / %d microns ^ 2\n",SAspacing,totSA,nBSyn)
        SAcnt = 0
        // note: we do NOT reinitialize 'cnt' here.

        numSec = 0
        forsec middend { numSec += 1 }

        cntSec = 0
        forsec middend {
            cntSec += 1
	    for(x) {
	        SAcnt += area(x)
	        while( SAcnt >= SAspacing ) {
		    // add synapse here

		    sref = new SectionRef()
		    $o6.append()
		    $o7.append(x)

		    //printf("SynLoc[%d] %s(%g) Dist %g\tCutoff %g > %g, total %g out of %g\n",cnt,secname(),x,distance(x), SAcnt,SAspacing,SAcnt+cnt*SAspacing,totSA)
		    Esyndend[cnt] = new Exp2Syn(x)
		    Esyndend[cnt].tau1=AMPA_tau1  //--- ms decay time constatn
		    Esyndend[cnt].tau2=AMPA_tau2  //--- ms decay time constatn
		    Esyndend[cnt].e=AMPA_Esyn //-- mV reversal potential


		    stimEsyndend[cnt]= new NetStim(x)
		    stimEsyndend[cnt].interval=  100
		    stimEsyndend[cnt].start= $3 + cnt*DELAY
		    stimEsyndend[cnt].noise=0
		    stimEsyndend[cnt].number=1

	            connEsyndend[cnt] = new NetCon(stimEsyndend[cnt],Esyndend[cnt],-55,0,AMPA_g)
	            connEsyndend[cnt].record(tvec, idvec, cnt)
	            cnt += 1

		    SAcnt -= SAspacing
	        }
    	    }
            // if it's the end of the SectionList and we still have a synapse to add, put it here.
	    if( cnt < nSyn && cntSec == numSec ) {
	        //printf("---Added %d synapses, need a total of %d\n",cnt,nSyn)
	        while( cnt < nASyn+nBSyn ) {
	            xloc = 1

		    // add synapse here

		    sref = new SectionRef()
		    $o6.append()
		    $o7.append(xloc)

		    //printf("\t\tSynLoc[%d] %s(%g) Dist %g\n",cnt,secname(),xloc,distance(xloc))
		    Esyndend[cnt] = new Exp2Syn(xloc)
		    Esyndend[cnt].tau1=AMPA_tau1  //--- ms decay time constatn
		    Esyndend[cnt].tau2=AMPA_tau2  //--- ms decay time constatn
		    Esyndend[cnt].e=AMPA_Esyn //-- mV reversal potential


		    stimEsyndend[cnt]= new NetStim(xloc)
		    stimEsyndend[cnt].interval=  100
		    stimEsyndend[cnt].start= $4 + cnt*DELAY
		    stimEsyndend[cnt].noise=0
		    stimEsyndend[cnt].number=1

		    
	            connEsyndend[cnt] = new NetCon(stimEsyndend[cnt],Esyndend[cnt],-55,0,AMPA_g)
	            connEsyndend[cnt].record(tvec, idvec, cnt)
	            cnt += 1
	        }
            }
        }
        printf("Finished with middend dendrites, added %d synapses, %g SA till next synapse\n",cnt,SAcnt)

    } else {  printf("No Middend synapses added.\n")  }


        // now distal synapses
        
    L_max=0
    forsec all{
		for(x) {
			if(L >=L_max) {
			L_max = L}
			}
	}
	
    if( nCSyn > 0 ) {

        totSA = 0
        
        forsec distal {
        for(x) {
        if(L>=2/3*L_max){
	        totSA += L*3.1415926*diam}
	        }
	        }
	        
        SAspacing = totSA / nCSyn
        printf("Spacing for distal EXC synapses:  every %g = %g / %d microns ^ 2\n",SAspacing,totSA,nCSyn)
        SAcnt = 0
        // note: we do NOT reinitialize 'cnt' here.

        numSec = 0
        forsec distal { for(x) {if(L>=2/3*L_max) {numSec += 1 }}}

        cntSec = 0
        forsec distal {
        
            cntSec += 1
	    for(x) {
	    	if(L>=2/3*L_max) {
	        SAcnt += area(x)
	        while( SAcnt >= SAspacing ) {
		    // add synapse here

		    sref = new SectionRef()
		    $o6.append()
		    $o7.append(x)

		    printf("SynLoc[%d] %s(%g) Dist %g\tCutoff %g > %g, total %g out of %g\n",cnt,secname(),x,distance(x), SAcnt,SAspacing,SAcnt+cnt*SAspacing,totSA)
		    Esyndend[cnt] = new Exp2Syn(x)
		    Esyndend[cnt].tau1=AMPA_tau1  //--- ms decay time constatn
		    Esyndend[cnt].tau2=AMPA_tau2  //--- ms decay time constatn
		    Esyndend[cnt].e=AMPA_Esyn //-- mV reversal potential


		    stimEsyndend[cnt]= new NetStim(x)
		    stimEsyndend[cnt].interval=  100
		    stimEsyndend[cnt].start= $3 + cnt*DELAY
		    stimEsyndend[cnt].noise=0
		    stimEsyndend[cnt].number=1

		    
	            connEsyndend[cnt] = new NetCon(stimEsyndend[cnt],Esyndend[cnt],-55,0,AMPA_g)
	            connEsyndend[cnt].record(tvec, idvec, cnt)
	            cnt += 1

		    SAcnt -= SAspacing
	        }
    	    }
    	}
    	/********
            // if it's the end of the SectionList and we still have a synapse to add, put it here.
	    if( cnt < nSyn && cntSec == numSec ) {
	        printf("---Added %d synapses, need a total of %d\n",cnt,nSyn)
	        while( cnt < nSyn ) {
	            xloc = 1

		    // add synapse here

		    sref = new SectionRef()
		    $o6.append()
		    $o7.append(xloc)

		    printf("\t\tSynLoc[%d] %s(%g) Dist %g\n",cnt,secname(),xloc,distance(xloc))
		    Esyndend[cnt] = new Exp2Syn(xloc)
		    Esyndend[cnt].tau1=AMPA_tau1  //--- ms decay time constatn
		    Esyndend[cnt].tau2=AMPA_tau2  //--- ms decay time constatn
		    Esyndend[cnt].e=AMPA_Esyn //-- mV reversal potential


		    stimEsyndend[cnt]= new NetStim(xloc)
		    stimEsyndend[cnt].interval=  100
		    stimEsyndend[cnt].start= $4 + cnt*DELAY
		    stimEsyndend[cnt].noise=0
		    stimEsyndend[cnt].number=1

	            connEsyndend[cnt] = new NetCon(stimEsyndend[cnt],Esyndend[cnt],-55,0,AMPA_g)
	            connEsyndend[cnt].record(tvec, idvec, cnt)
	            cnt += 1
	        }
            }

        ********/
        }
        printf("Finished with distal dendrites, added %d synapses, %g SA till next synapse\n",cnt,SAcnt)

    } else {  printf("No distal synapses added.\n")  }
    
    printf("Added %d excitatory synapses, final time %d\n",nSyn,START_EXC + nSyn*DELAY)

    return nSyn
    



}



/*********************************************

    input	$1	total number of inhibitory synapses
		$2	maximal distance from soma for dendritic inhib synapses
		$3	starting time of excitation
		$4	timing between subsequent PSPs
		$o5	SectionList to which sections are added
		$o6	vector of locations
		$7	count of sections added

*********************************************/
func AddInhSynapses() { local cnt, nSyn, DELAY, ST_EXC, stopTime, SAspacing, totSA, SAcnt, numSec, cntSec, xloc

    nSyn   = $1
    ST_EXC = $3
    DELAY  = $4

    totSA = countSA($2)
    SAspacing = totSA / nSyn
    printf("Spacing for INH synapses:  every %g = %g / %d microns ^ 2\n",SAspacing,totSA,nSyn)

    objref stimIsyndend[nSyn], connIsyndend[nSyn], Isyndend[nSyn]

    soma { distance(0) }

    SAcnt = 0
    cnt = 0
    $o5 = new SectionList()
    $o6 = new Vector()

    forsec "soma" { 
	for(x) {
	    SAcnt += area(x)
	    while( SAcnt >= SAspacing ) {
		sref = new SectionRef()
		$o5.append()
		$o6.append(x)

		// add synapse here
		//printf("SynLoc %s(%g)\tCutoff %g > %g, total %g out of %g\n",secname(),x,SAcnt,SAspacing,SAcnt+cnt*SAspacing,totSA)
		Isyndend[cnt] = new Exp2Syn(x)  	// PICK UP HERE!!!! 
print "\tAdded Exp2Syn"
		Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
print "\tset tau1"
		Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
print "\tset tau2"
		Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential
print "\tset Esyn"

		stimIsyndend[cnt]= new NetStim(x)
print "\tAdded NetStim"
		stimIsyndend[cnt].interval=  100
		stimIsyndend[cnt].start= $3 + cnt*DELAY
		stimIsyndend[cnt].noise=0
		stimIsyndend[cnt].number=1
print "\tset NetStim params"

	        connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)
print "\tAdded NetCon"

        	cnt += 1

		SAcnt -= SAspacing

	    }

	}
    }
    printf("Finished with soma, added %d synapses, %g SA till next synapse\n",cnt,SAcnt)

    numSec = 0
    forsec dendritic { numSec += 1 }

    cntSec = 0
    forsec dendritic {
        cntSec += 1
	for(x) {
	    if( distance(x) > $2 ) continue

	    SAcnt += area(x)
	    while( SAcnt >= SAspacing ) {
		// add synapse here

		sref = new SectionRef()
		$o5.append()
		$o6.append(x)

		//printf("SynLoc[%d] %s(%g) Dist %g\tCutoff %g > %g, total %g out of %g\n",cnt,secname(),x,distance(x), SAcnt,SAspacing,SAcnt+cnt*SAspacing,totSA)
		Isyndend[cnt] = new Exp2Syn(x)
		Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		stimIsyndend[cnt]= new NetStim(x)
		stimIsyndend[cnt].interval=  100
		stimIsyndend[cnt].start= $3 + cnt*DELAY
		stimIsyndend[cnt].noise=0
		stimIsyndend[cnt].number=1

	        connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	        cnt += 1

		SAcnt -= SAspacing
	    }
    	}
        // if it's the end of the SectionList and we still have a synapse to add, put it here.
	if( cnt < nSyn && cntSec == numSec ) {
	    //printf("---Added %d synapses, need a total of %d\n",cnt,nSyn)
	    while( cnt < nSyn ) {
	        xloc = 1

		// add synapse here

		sref = new SectionRef()
		$o5.append()
		$o6.append(xloc)

		//printf("\t\tSynLoc[%d] %s(%g) Dist %g\n",cnt,secname(),xloc,distance(xloc))
		Isyndend[cnt] = new Exp2Syn(xloc)
		Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		stimIsyndend[cnt]= new NetStim(xloc)
		stimIsyndend[cnt].interval=  70
		stimIsyndend[cnt].start= $3 + cnt*DELAY
		stimIsyndend[cnt].noise=0
		stimIsyndend[cnt].number=1

	        connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	        cnt += 1
	    }
        }
    }
    printf("Finished with dendrites, added %d synapses, %g SA till next synapse\n",cnt,SAcnt)

    stopTime = START_EXC+(nSyn+2)*DELAY
    printf("Added %d inhibitory synapses, final time %d\n",nSyn,START_EXC + nSyn*DELAY)

    $7 = cnt

    return stopTime
}





/*********************************************

    input	$1	total number of inhibitory synapses
		$2	maximal distance from soma for dendritic inhib synapses
		$3	starting time of excitation
		$4	timing between subsequent PSPs
		$o5	SectionList to which sections are added
		$o6	vector of locations
		$7	count of sections added
		$8	proportion of all synapses to distribute proximally

    Distribute a proportion of the total number of inhibitory synapse close to 
    the soma.  Then, distribute the rest uniformly across the whole soma and 
    dendrites.

*********************************************/
func AddInhSynapses_ProxAndUni() { local cnt, nSyn, DELAY, ST_EXC, stopTime, SAspacing, totSA, prxSA, SAcnt, numSec, cntSec, xloc, nClose, nFar

    nSyn   = $1
    ST_EXC = $3
    DELAY  = $4
    nClose = int(nSyn * $8 + 0.5 )
    nFar   = nSyn - nClose 


    objref stimIsyndend[nSyn], connIsyndend[nSyn], Isyndend[nSyn]
    $o5 = new SectionList()
    $o6 = new Vector()

    soma { distance(0) }

    numSec = 0
    forsec dendritic { numSec += 1 }

    /**** STEP 1:  distribute a proportion the synapses on the soma & proximal dendrites.  ****/

    prxSA = countSA($2)
    SAspacing = prxSA / nClose
    printf("Spacing for proximal INH synapses:  every %g = %g / %d microns ^ 2\n",SAspacing,prxSA,nClose)

    SAcnt = 0
    cnt = 0
    forsec "soma" { 
	for(x) {
	    SAcnt += area(x)
	    while( SAcnt >= SAspacing ) {
		sref = new SectionRef()
		$o5.append()
		$o6.append(x)

		// add synapse here
		//printf("SOMA:  SynLoc %s(%g)\tCutoff %g > %g, total %g out of %g\n",secname(),x,SAcnt,SAspacing,SAcnt+cnt*SAspacing,totSA)
		Isyndend[cnt] = new Exp2Syn(x)  	
		Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		stimIsyndend[cnt]= new NetStim(x)
		stimIsyndend[cnt].interval=  70
		stimIsyndend[cnt].start= $3 + cnt*DELAY
		stimIsyndend[cnt].noise=0
		stimIsyndend[cnt].number=1

	        connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

        	cnt += 1

		SAcnt -= SAspacing

	    }

	}
    }
    printf("Finished with soma, added %d synapses, %g SA till next synapse\n",cnt,SAcnt)

    cntSec = 0
    forsec dendritic {
        cntSec += 1
	for(x) {
	    if( distance(x) > $2 ) continue

	    SAcnt += area(x)
	    while( SAcnt >= SAspacing ) {
		// add synapse here

		sref = new SectionRef()
		$o5.append()
		$o6.append(x)

		//printf("PROX:  SynLoc[%d] %s(%g) Dist %g\tCutoff %g > %g, total %g out of %g\n",cnt,secname(),x,distance(x), SAcnt,SAspacing,SAcnt+cnt*SAspacing,totSA)
		Isyndend[cnt] = new Exp2Syn(x)
		Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		stimIsyndend[cnt]= new NetStim(x)
		stimIsyndend[cnt].interval=  70
		stimIsyndend[cnt].start= $3 + cnt*DELAY
		stimIsyndend[cnt].noise=0
		stimIsyndend[cnt].number=1

	        connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	        cnt += 1

		SAcnt -= SAspacing
	    }
    	}
    }
    printf("Finished with proximal dendrites, added %d synapses, %g SA till next synapse\n",cnt,SAcnt)


    /**** STEP 2:  distribute remaining synapses througout medial and distal dendrites.  ****/

    if( nFar > 0 ) {

        totSA = countSA(70)
        SAspacing = (totSA - prxSA ) / nFar
        printf("Spacing for distal INH synapses:  every %g = %g / %d microns ^ 2\n",SAspacing,(totSA-prxSA),nFar)

        SAcnt = 0
        cntSec = 0
        forsec dendritic {
            cntSec += 1
	    for(x) {
	        if( distance(x) <= $2 ) continue

   	        SAcnt += area(x)
	        while( SAcnt >= SAspacing ) {
		    // add synapse here

 		    sref = new SectionRef()
		    $o5.append()
		    $o6.append(x)

		    //printf("DISTAL:  SynLoc[%d] %s(%g) Dist %g\tCutoff %g > %g, total %g out of %g\n",cnt,secname(),x,distance(x), SAcnt,SAspacing,SAcnt+cnt*SAspacing,(totSA-prxSA))
		    Isyndend[cnt] = new Exp2Syn(x)
		    Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		    Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		    Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		    stimIsyndend[cnt]= new NetStim(x)
		    stimIsyndend[cnt].interval=  70
		    stimIsyndend[cnt].start= $3 + cnt*DELAY
		    stimIsyndend[cnt].noise=0
		    stimIsyndend[cnt].number=1

	            connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	            cnt += 1

		    SAcnt -= SAspacing
	        }
    	    }
            // if it's the end of the SectionList and we still have a synapse to add, put it here.
	    if( cnt < nSyn && cntSec == numSec ) {
	        //printf("---Added %d synapses, need a total of %d\n",cnt,nSyn)
	        while( cnt < nSyn ) {
	            xloc = 1

		    // add synapse here

		    sref = new SectionRef()
		    $o5.append()
		    $o6.append(xloc)

		    //printf("\t\tSynLoc[%d] END %s(%g) Dist %g\n",cnt,secname(),xloc,distance(xloc))
		    Isyndend[cnt] = new Exp2Syn(xloc)
		    Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		    Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		    Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		    stimIsyndend[cnt]= new NetStim(xloc)
		    stimIsyndend[cnt].interval=  70
		    stimIsyndend[cnt].start= $3 + cnt*DELAY
		    stimIsyndend[cnt].noise=0
		    stimIsyndend[cnt].number=1

	            connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	            cnt += 1
	        }
            }
        }
        printf("Finished with dendrites, added %d synapses, %g SA till next synapse\n",cnt,SAcnt)    
    }


    stopTime = START_EXC+(nSyn+2)*DELAY
    printf("Added %d inhibitory synapses, final time %d\n",nSyn,START_EXC + nSyn*DELAY)

    $7 = cnt

    return stopTime
}









/*********************************************

    input	$1	base density of inhibitory synapses
		$2	maximal distance from soma for dendritic inhib synapses
		$3	starting time of excitation
		$4	timing between subsequent PSPs
		$o5	SectionList to which sections are added
		$o6	vector of locations
		$7	count of sections added
		$8	inhib synapse density on proximal spines
		$9	inhib synapse density on distal spines

    Specify a baseline density of inhibitory synapse throughout dendrites, and 
    extra density terms to represent inhib synapses that would have been on 
    dendritic spines.  Distribute these uniformly in their respective regions.

*********************************************/
func AddInhSynapses_ProxDist_byDensity() { local cnt, nSyn, DELAY, ST_EXC, stopTime, Lspacing, totSA, prxSA, Lcnt, numSec, cntSec, xloc, nClose, nFar, baseDens, prxSpDens, dstSpDens, totL, prxL, dstL, lastX

    baseDens = $1
    ST_EXC = $3
    DELAY  = $4

    prxL = find_totLen($2)
    totL = find_totLen(70)
    dstL = totL - prxL
    prxSpDens = $8
    dstSpDens = $9

    nClose = int(prxL * (baseDens + prxSpDens) + 0.5 )
    nFar   = int(dstL * (baseDens + dstSpDens) + 0.5 )
    nSyn = nClose + nFar
    printf("Inh syn density:  %g base/t%g prox Spines/t%g dist Spines\n",baseDens,prxSpDens,dstSpDens)
    printf("Want a total of %d synapses: %d close and %d far from soma.\n",nSyn,nClose,nFar)



    objref stimIsyndend[nSyn], connIsyndend[nSyn], Isyndend[nSyn]
    $o5 = new SectionList()
    $o6 = new Vector()

    soma { distance(0) }

    numSec = 0
    forsec dendritic { numSec += 1 }

    /**** STEP 1:  distribute a proportion the synapses on the soma & proximal dendrites.  ****/

    Lspacing = prxL / nClose
    printf("Spacing for proximal INH synapses:  every %g = %g / %d microns of length\n",Lspacing,prxL,nClose)

    Lcnt = 0
    cnt = 0
    forsec "soma" { 
	for(x) {
	    if( x==0 || x == 1 ) continue

	    Lcnt += L / nseg
	    while( Lcnt >= Lspacing ) {
		sref = new SectionRef()
		$o5.append()
		$o6.append(x)

		// add synapse here
		//printf("SOMA:  SynLoc %s(%g)\tCutoff %g > %g, total %g out of %g\n",secname(),x,Lcnt,Lspacing,Lcnt+cnt*Lspacing,totL)
		Isyndend[cnt] = new Exp2Syn(x)  	
		Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		stimIsyndend[cnt]= new NetStim(x)
		stimIsyndend[cnt].interval=  70
		stimIsyndend[cnt].start= $3 + cnt*DELAY
		stimIsyndend[cnt].noise=0
		stimIsyndend[cnt].number=1

	        connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

        	cnt += 1

		Lcnt -= Lspacing

	    }

	}
    }
    printf("Finished with soma, added %d synapses, %g L till next synapse\n",cnt,Lcnt)

    cntSec = 0
    forsec dendritic {
        cntSec += 1
	for(x) {
	    if( distance(x) > $2 ) { continue }
	    //if( distance(x) > $2 ) { printf("---- Skip %s\t",secname() ) continue }
	    if( x==0 || x==1 ) continue

	    Lcnt += L / nseg
	    //printf("\n\t+++\t%s(%g) L add %g -> Lcnt %g\n",secname(),x,L/nseg,Lcnt)

	    while( Lcnt >= Lspacing ) {

                if( cnt > nClose ) { printf("\ttrying to add synapse %d\n",cnt) }
		// add synapse here

		sref = new SectionRef()
		$o5.append()
		$o6.append(x)

		//printf("PROX:  SynLoc[%d] %s(%g) Dist %g\tCutoff %g > %g, total %g out of %g\n",cnt,secname(),x,distance(x), Lcnt,Lspacing,Lcnt+cnt*Lspacing,prxL)
		Isyndend[cnt] = new Exp2Syn(x)
		Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential
 
		stimIsyndend[cnt]= new NetStim(x)
		stimIsyndend[cnt].interval=  70
		stimIsyndend[cnt].start= $3 + cnt*DELAY
		stimIsyndend[cnt].noise=0
		stimIsyndend[cnt].number=1

	        connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	        cnt += 1

		Lcnt -= Lspacing
	    } 
    	}
    }
    printf("Finished with proximal dendrites, added %d synapses, %g length till next synapse\n",cnt,Lcnt)


    /**** STEP 2:  distribute remaining synapses througout medial and distal dendrites.  ****/

    //Lcnt = 0

    if( nFar > 0 ) {	// continue here.

        Lspacing = dstL / nFar
        printf("Spacing for distal INH synapses:  every %g = %g / %d microns of length\n",Lspacing,dstL,nFar)

        //Lcnt = 0
        cntSec = 0
        forsec dendritic {
            cntSec += 1
	    for(x) {
	        if( x==0 || x==1 ) continue
	        if( distance(x) <= $2 ) continue

   	        Lcnt += L / nseg
	        while( Lcnt >= Lspacing && cnt < nSyn ) {
		    // add synapse here

 		    sref = new SectionRef()
		    $o5.append()
		    $o6.append(x)

		    //printf("DISTAL:  SynLoc[%d] %s(%g) Dist %g\tCutoff %g > %g, total %g out of %g\n",cnt,secname(),x,distance(x), Lcnt,Lspacing,Lcnt+cnt*Lspacing,dstL)
		    Isyndend[cnt] = new Exp2Syn(x)
		    Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		    Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		    Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		    stimIsyndend[cnt]= new NetStim(x)
		    stimIsyndend[cnt].interval=  70
		    stimIsyndend[cnt].start= $3 + cnt*DELAY
		    stimIsyndend[cnt].noise=0
		    stimIsyndend[cnt].number=1

	            connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	            cnt += 1

		    Lcnt -= Lspacing
	        }
    	    }
            // if it's the end of the SectionList and we still have a synapse to add, put it here.
	    if( cnt < nSyn && cntSec == numSec ) {
	        //printf("---Added %d synapses, need a total of %d\n",cnt,nSyn)
	        while( cnt < nSyn ) {
	            xloc = 1

		    // add synapse here

		    sref = new SectionRef()
		    $o5.append()
		    $o6.append(xloc)

		    //printf("\t\tSynLoc[%d] END %s(%g) Dist %g\n",cnt,secname(),xloc,distance(xloc))
		    Isyndend[cnt] = new Exp2Syn(xloc)
		    Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		    Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		    Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		    stimIsyndend[cnt]= new NetStim(xloc)
		    stimIsyndend[cnt].interval=  70
		    stimIsyndend[cnt].start= $3 + cnt*DELAY
		    stimIsyndend[cnt].noise=0
		    stimIsyndend[cnt].number=1

	            connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	            cnt += 1
	        }
            }
        }
        printf("Finished with dendrites, added %d synapses, %g length till next synapse\n",cnt,Lcnt)    
    }


    stopTime = START_EXC+(nSyn+2)*DELAY
    printf("Added %d inhibitory synapses, final time %d\n",nSyn,START_EXC + nSyn*DELAY)

    $7 = cnt

    return nSyn
    //return stopTime
}







/*********************************************

    input	$1	base density of inhibitory synapses
		$2	maximal distance from soma for dendritic inhib synapses
		$3	starting time of excitation
		$4	timing between subsequent PSPs
		$o5	SectionList to which sections are added
		$o6	vector of locations
		$7	count of sections added
		$8	inhib synapse density on proximal spines
		$9	inhib synapse density on distal spines
		$10	if 0, do only apical; if 1, do only basal; else do both.

    Specify a baseline density of inhibitory synapse throughout dendrites, and 
    extra density terms to represent inhib synapses that would have been on 
    dendritic spines.  Distribute these uniformly in their respective regions.

*********************************************/
func AddInhSynapses_ProxDist_byDensityAB() { local cnt, nSyn, DELAY, ST_EXC, stopTime, Lspacing, totSA, prxSA, Lcnt, numSec, cntSec, xloc, nClose, nFar, baseDens, prxSpDens, dstSpDens, totL, prxL, dstL, lastX

    baseDens = $1
    ST_EXC = $3
    DELAY  = $4

    if( $10 == 0 ) {
        prxL = find_totProxLen($2)
        totL = find_totProxLen(70)
    } else {
        if( $10 == 1 ) {
            prxL = find_totMiddLen($2)
            totL = find_totMiddLen(70)
        } else {
            prxL = find_totLen($2)
            totL = find_totLen(70)
        }
    }
    dstL = totL - prxL

    prxSpDens = $8
    dstSpDens = $9

    nClose = int(prxL * (baseDens + prxSpDens) + 0.5 )
    nFar   = int(dstL * (baseDens + dstSpDens) + 0.5 )
    nSyn = nClose + nFar
    printf("Inh syn density:  %g base/t%g prox Spines/t%g dist Spines\n",baseDens,prxSpDens,dstSpDens)
    printf("Want a total of %d synapses: %d close and %d far from soma.\n",nSyn,nClose,nFar)



    objref stimIsyndend[nSyn], connIsyndend[nSyn], Isyndend[nSyn]
    $o5 = new SectionList()
    $o6 = new Vector()

    soma { distance(0) }

    numSec = 0
    if( $10 == 0 ) { forsec proximal { numSec += 1 }
    } else {
        if( $10 ==1 ) {  forsec middend { numSec += 1 }
        } else {
            forsec distal { numSec += 1 }
        }
    }

    /**** STEP 1:  distribute a proportion the synapses on the soma & proximal dendrites.  ****/

    Lspacing = prxL / nClose
    printf("Spacing for proximal INH synapses:  every %g = %g / %d microns of length\n",Lspacing,prxL,nClose)

    Lcnt = 0
    cnt = 0

    /****  this section is the same regardless of whether we consider apical or basal only, or all dendrites ****/
    forsec "soma" { 
	for(x) {
	    if( x==0 || x == 1 ) continue

	    Lcnt += L / nseg
	    while( Lcnt >= Lspacing ) {
		sref = new SectionRef()
		$o5.append()
		$o6.append(x)

		// add synapse here
		//printf("SOMA:  SynLoc %s(%g)\tCutoff %g > %g, total %g out of %g\n",secname(),x,Lcnt,Lspacing,Lcnt+cnt*Lspacing,totL)
		Isyndend[cnt] = new Exp2Syn(x)  	
		Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		stimIsyndend[cnt]= new NetStim(x)
		stimIsyndend[cnt].interval=  70
		stimIsyndend[cnt].start= $3 + cnt*DELAY
		stimIsyndend[cnt].noise=0
		stimIsyndend[cnt].number=1

	        connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

        	cnt += 1

		Lcnt -= Lspacing

	    }

	}
    }
    printf("Finished with soma, added %d synapses, %g L till next synapse\n",cnt,Lcnt)

    cntSec = 0


    if( $10 != 1 ) {
        forsec proximal {
            cntSec += 1
	    for(x) {
	        if( distance(x) > $2 ) { continue }
  	        if( x==0 || x==1 ) continue

	        Lcnt += L / nseg

	        while( Lcnt >= Lspacing ) {

                    if( cnt > nClose ) { printf("\ttrying to add synapse %d\n",cnt) }
		    // add synapse here

	  	    sref = new SectionRef()
		    $o5.append()
		    $o6.append(x)

	  	    Isyndend[cnt] = new Exp2Syn(x)
		    Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		    Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		    Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential
 
		    stimIsyndend[cnt]= new NetStim(x)
		    stimIsyndend[cnt].interval=  70
		    stimIsyndend[cnt].start= $3 + cnt*DELAY
		    stimIsyndend[cnt].noise=0
		    stimIsyndend[cnt].number=1

	            connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	            cnt += 1

	  	    Lcnt -= Lspacing
	        } 
    	    }
        }
    } 

    if( $10 != 0 ) {
        forsec middend {
            cntSec += 1
	    for(x) {
	        if( distance(x) > $2 ) { continue }
  	        if( x==0 || x==1 ) continue

	        Lcnt += L / nseg

	        while( Lcnt >= Lspacing ) {

                    if( cnt > nClose ) { printf("\ttrying to add synapse %d\n",cnt) }
		    // add synapse here

	  	    sref = new SectionRef()
		    $o5.append()
		    $o6.append(x)

	  	    Isyndend[cnt] = new Exp2Syn(x)
		    Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		    Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		    Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential
 
		    stimIsyndend[cnt]= new NetStim(x)
		    stimIsyndend[cnt].interval=  70
		    stimIsyndend[cnt].start= $3 + cnt*DELAY
		    stimIsyndend[cnt].noise=0
		    stimIsyndend[cnt].number=1

	            connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	            cnt += 1

	  	    Lcnt -= Lspacing
	        } 
    	    }
        }
    } 

    
    printf("Finished with proximal dendrites, added %d synapses, %g length till next synapse\n",cnt,Lcnt)


    /**** STEP 2:  distribute remaining synapses througout medial and distal dendrites.  ****/

    if( nFar > 0 ) {	// continue here.

        Lspacing = dstL / nFar
        printf("Spacing for distal INH synapses:  every %g = %g / %d microns of length\n",Lspacing,dstL,nFar)

        cntSec = 0

	if( $10 == 0  ) {
            forsec proximal {
                cntSec += 1
	        for(x) {
	            if( x==0 || x==1 ) continue
	            if( distance(x) <= $2 ) continue

     	            Lcnt += L / nseg
	            while( Lcnt >= Lspacing && cnt < nSyn ) {
		        // add synapse here

 		        sref = new SectionRef()
		        $o5.append()
		        $o6.append(x)

		        Isyndend[cnt] = new Exp2Syn(x)
		        Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		        Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		        Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		        stimIsyndend[cnt]= new NetStim(x)
		        stimIsyndend[cnt].interval=  70
		        stimIsyndend[cnt].start= $3 + cnt*DELAY
		        stimIsyndend[cnt].noise=0
		        stimIsyndend[cnt].number=1

	                connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	                cnt += 1

		        Lcnt -= Lspacing
	            }
    	        }
                // if it's the end of the SectionList and we still have a synapse to add, put it here.
	        if( cnt < nSyn && cntSec == numSec ) {
	            while( cnt < nSyn ) {
	                xloc = 1

		        // add synapse here

		        sref = new SectionRef()
		        $o5.append()
		        $o6.append(xloc)

		        Isyndend[cnt] = new Exp2Syn(xloc)
		        Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		        Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		        Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		        stimIsyndend[cnt]= new NetStim(xloc)
		        stimIsyndend[cnt].interval=  70
		        stimIsyndend[cnt].start= $3 + cnt*DELAY
		        stimIsyndend[cnt].noise=0
		        stimIsyndend[cnt].number=1

	                connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	                cnt += 1
	            }
                }
            }
	}
	if( $10 == 1 ) {
            forsec middend {
                cntSec += 1
	        for(x) {
	            if( x==0 || x==1 ) continue
	            if( distance(x) <= $2 ) continue

     	            Lcnt += L / nseg
	            while( Lcnt >= Lspacing && cnt < nSyn ) {
		        // add synapse here

 		        sref = new SectionRef()
		        $o5.append()
		        $o6.append(x)

		        Isyndend[cnt] = new Exp2Syn(x)
		        Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		        Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		        Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		        stimIsyndend[cnt]= new NetStim(x)
		        stimIsyndend[cnt].interval=  70
		        stimIsyndend[cnt].start= $3 + cnt*DELAY
		        stimIsyndend[cnt].noise=0
		        stimIsyndend[cnt].number=1

	                connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	                cnt += 1

		        Lcnt -= Lspacing
	            }
    	        }
                // if it's the end of the SectionList and we still have a synapse to add, put it here.
	        if( cnt < nSyn && cntSec == numSec ) {
	            while( cnt < nSyn ) {
	                xloc = 1

		        // add synapse here

		        sref = new SectionRef()
		        $o5.append()
		        $o6.append(xloc)

		        Isyndend[cnt] = new Exp2Syn(xloc)
		        Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		        Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		        Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		        stimIsyndend[cnt]= new NetStim(xloc)
		        stimIsyndend[cnt].interval=  70
		        stimIsyndend[cnt].start= $3 + cnt*DELAY
		        stimIsyndend[cnt].noise=0
		        stimIsyndend[cnt].number=1

	                connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	                cnt += 1
	            }
                }
            }
	}
	if( ($10 != 0 ) && ($10 != 1) ) {
            forsec dendritic {
                cntSec += 1
	        for(x) {
	            if( x==0 || x==1 ) continue
	            if( distance(x) <= $2 ) continue

     	            Lcnt += L / nseg
	            while( Lcnt >= Lspacing && cnt < nSyn ) {
		        // add synapse here

 		        sref = new SectionRef()
		        $o5.append()
		        $o6.append(x)

		        Isyndend[cnt] = new Exp2Syn(x)
		        Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		        Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		        Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		        stimIsyndend[cnt]= new NetStim(x)
		        stimIsyndend[cnt].interval=  70
		        stimIsyndend[cnt].start= $3 + cnt*DELAY
		        stimIsyndend[cnt].noise=0
		        stimIsyndend[cnt].number=1

	                connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	                cnt += 1

		        Lcnt -= Lspacing
	            }
    	        }
                // if it's the end of the SectionList and we still have a synapse to add, put it here.
	        if( cnt < nSyn && cntSec == numSec ) {
	            while( cnt < nSyn ) {
	                xloc = 1

		        // add synapse here

		        sref = new SectionRef()
		        $o5.append()
		        $o6.append(xloc)

		        Isyndend[cnt] = new Exp2Syn(xloc)
		        Isyndend[cnt].tau1=GABAa_tau1  //--- ms decay time constatn
		        Isyndend[cnt].tau2=GABAa_tau2  //--- ms decay time constatn
		        Isyndend[cnt].e=GABAa_Esyn //-- mV reversal potential

		        stimIsyndend[cnt]= new NetStim(xloc)
		        stimIsyndend[cnt].interval=  70
		        stimIsyndend[cnt].start= $3 + cnt*DELAY
		        stimIsyndend[cnt].noise=0
		        stimIsyndend[cnt].number=1

	                connIsyndend[cnt] = new NetCon(stimIsyndend[cnt],Isyndend[cnt],-55,0,GABAa_g)

	                cnt += 1
	            }
                }
            }
	}

        printf("Finished with dendrites, added %d synapses, %g length till next synapse\n",cnt,Lcnt)    
    }


    stopTime = START_EXC+(nSyn+2)*DELAY
    printf("Added %d inhibitory synapses, final time %d\n",nSyn,START_EXC + nSyn*DELAY)

    $7 = cnt

    return nSyn
}





proc SynapsesOff() { local i

    for i = 0, $1-1 {
        stimEsyndend[i].start = 70
    }
}

proc SynapseOn() {
    stimEsyndend[$1].start = $2
}



/********
	input   $1	value of gAMPA
		$2	number of synapses
********/
proc adjust_gAMPA() {  local i

    for i = 0, $2-1 {
	connEsyndend[i].weight = $1
    }
}


/********
	input   $1	value of gAMPA
		$2	number of synapses
********/
proc adjust_gGABA() {  local i

    for i = 0, $2-1 {
	connIsyndend[i].weight = $1
    }
}



/********
	input   $1	value of tau1 for Exp2Syn
		$2	number of synapses
********/
proc adjust_tau1() {  local i

    for i = 0, $2-1 {
	Esyndend[i].tau1 = $1
    }
}



/********
	input   $1	value of tau1 for Exp2Syn
		$2	number of synapses
********/
proc adjust_tau2() {  local i

    for i = 0, $2-1 {
	Esyndend[i].tau2 = $1
    }
}




/********
	input   $1	value of tau1 for Exp2Syn
		$2	number of synapses
********/
proc adjust_Itau1() {  local i

    for i = 0, $2-1 {
	Isyndend[i].tau1 = $1
    }
}



/********
	input   $1	value of tau1 for Exp2Syn
		$2	number of synapses
********/
proc adjust_Itau2() {  local i

    for i = 0, $2-1 {
	Isyndend[i].tau2 = $1
    }
}


/******************
	input 	$1 	max distance to count, or -1 if full dendrites only should be counted
******************/
func countSA() { local sa

    sa = 0

    if( $1 >= 0 ) { forsec "soma" for(x) sa += area(x) }

    forsec dendritic {
	for(x) {
            if( $1< 0 ||  distance(x) <= $1 ) {
                //printf("%s\t%g\t%g\t%g\n",secname(), x, distance(x), area(x) )
		sa += area(x)
	    }
        }
    }

    return sa
}


